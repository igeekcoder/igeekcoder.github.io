<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekCoder</title>
  
  <subtitle>极客码农</subtitle>
  <link href="/test_page/atom.xml" rel="self"/>
  
  <link href="http://igeek2020.gitee.io/test_page/"/>
  <updated>2020-07-26T16:22:56.319Z</updated>
  <id>http://igeek2020.gitee.io/test_page/</id>
  
  <author>
    <name>EthanXQ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重构之设计模式</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-26T04:12:46.025Z</published>
    <updated>2020-07-26T16:22:56.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构之常用设计模式"><a href="#重构之常用设计模式" class="headerlink" title="重构之常用设计模式"></a>重构之常用设计模式</h1><p>程序员三板斧：<code>数据结构</code>、<code>算法</code>、<code>设计模式</code></p><p>作为程序员无论你学习使用的是哪种语言，这三板斧都需要涉及甚至是需要深入了解的，这也是一个程序员基本功的展现，最近在做一些业务代码的重构也尝试使用了一些设计模式，今天和大家聊一聊我的一些见解和工作常用的一些<code>设计模式</code></p><h4 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h4><blockquote><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p><p>项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></blockquote><h4 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h4><h5 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h5><p>单例（Singleton）模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。在实际开发过程中，我们常常需要保存一些数据实现全局共享，这时候就需要用到单例模式。单例模式是在实际开发过程中使用比较多的一种设计模式。</p><blockquote><p>单例模式在spring中广泛应用 spring默认bean也是单例，适用于一些无状态的类，减少类的创建和销毁，需要注意的是共享变量需要考虑线程安全的问题，相对比较简单对于有些设计模式大师来说可能都算不上一种设计模式，更确切的来说是一种方法技巧, 这里就不详细分析了</p></blockquote><h5 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2.策略模式"></a>2.策略模式</h5><p>举个栗子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单支付</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> payType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orderBO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span> <span class="params">(String payType, OrderBO orderBO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"paypal"</span>.equals(payType)) &#123;</span><br><span class="line">        <span class="comment">// paypal 支付逻辑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"wechatPay"</span>.equals(payType)) &#123;</span><br><span class="line">        <span class="comment">// 微信支付逻辑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"aliPay"</span>.equals(payType)) &#123;</span><br><span class="line">        <span class="comment">// 支付宝支付逻辑</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"unionPay"</span>.equals(payType))&#123;</span><br><span class="line">        <span class="comment">// 银联支付逻辑</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似上面这段代码，我们在平时开发中可能会经常见到，存在什么问题？条件分支多，并且可能有持续增长的趋势 ，更有些判断条件复杂，上下文中的参数可能相互影响 并且if 里面可能还需要嵌套 if 或者 循环体 整个代码看着就很臃肿改起来很容易出错， 下面我们用策略模式实现</p></blockquote><h6 id="策略模式的定义："><a href="#策略模式的定义：" class="headerlink" title="策略模式的定义："></a>策略模式的定义：</h6><p>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，一般情况下我们是将一种行为写成一个类方法，比如计算器类中有加、减、乘、除四种方法，而策略模式则是将每一种算法都写成一个类，然后动态地选择使用哪一个算法</p><p><img src="/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2222997-69678af9fd117ec3.webp" alt="img"></p><p>从 UML 类图中，我们可以看到，<code>策略模式</code> 主要包含三种角色：</p><ul><li><p><strong>上下文角色（Context）</strong>：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略，算法的直接访问，封装可能存在的变化；</p></li><li><p><strong>抽象策略角色（Strategy）</strong>：规定策略或算法的行为；</p></li><li><p><strong>具体策略角色（ConcreteStrategy）</strong>：具体的策略或算法实现；</p></li></ul><p>在<code>Spring</code>中使用策略模式后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orderBO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">( OrderBO orderBO)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"paypal"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPal</span> <span class="keyword">implements</span> <span class="title">Payment</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(OrderBO orderBO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// paypal 支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"wechatPay"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPay</span> <span class="keyword">implements</span> <span class="title">Payment</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(OrderBO orderBO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// wechatPay 支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">Payment</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(OrderBO orderBO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// aliPay 支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aliPay"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Payment&gt; paymentMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(String payType, OrderBO orderBO)</span> </span>&#123;</span><br><span class="line">        Payment payment = paymentMap.get(payType);</span><br><span class="line">        payment.pay(orderBO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样各种支付方式相互独立清晰，需要接入新的支付方式只需要实现<code>Payment</code> 接口就可以了原有的支付逻辑都是可以不用去改变，从而实现 开闭原则（对扩展开放，对修改关闭）。</p><h5 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3.责任链模式"></a>3.责任链模式</h5><p>责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。</p><p><img src="/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2222997-7caeb17aacd80332.webp" alt="img"></p><h6 id="简单责任链"><a href="#简单责任链" class="headerlink" title="简单责任链"></a>简单责任链</h6><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(CustomerInfo customerInfo)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 保存用户</span></span><br><span class="line">    save(customerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.发送邮件</span></span><br><span class="line">    sendSuccessEmail(customerInfo.getEmail());</span><br><span class="line">    <span class="comment">// 2.初始化setting</span></span><br><span class="line">    initSetting(customerInfo);</span><br><span class="line">    <span class="comment">// 3.购买默认0元套餐</span></span><br><span class="line">    buyCombo(customerInfo.getCustomerCode());</span><br><span class="line">    <span class="comment">// 4.默认选择</span></span><br><span class="line">    selectPackageMethod(customerInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 6 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下单</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(OrderBO orderBO)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.基本参数检查</span></span><br><span class="line">    checkParam(orderBO);</span><br><span class="line">    <span class="comment">// 2.风控检查</span></span><br><span class="line">    riskCheck(orderBo)</span><br><span class="line">    <span class="comment">// 3.商品库存检查</span></span><br><span class="line">    checkGoods(orderBo)</span><br><span class="line">    <span class="comment">// 4. 5 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是一段伪代码 </p><p>第一注册功能 注册完之后需要给用户<code>发送邮件</code>，<code>初始化默认设置</code>，<code>购买默认套餐</code>，<code>选择默认打包服务</code></p><p>第二个是一个下单功能 下单前要做各种检查 没准什么时候又来个<code>购买的服务数量检查</code>等等</p></blockquote><p>在spring中使用有顺序的责任链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AfterRegisterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AfterRegisterHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(CustomerInfo customerInfo)</span> </span>&#123;</span><br><span class="line">        doAfter(customerInfo);</span><br><span class="line">        <span class="keyword">if</span> (getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            getNext().doAfter(customerInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">doAfter</span><span class="params">(CustomerInfo customerInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRegisterAfterProcess</span> <span class="keyword">extends</span> <span class="title">RegisterAfterProcess</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(CustomerInfo customerInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComboRegisterAfterProcess</span> <span class="keyword">extends</span> <span class="title">RegisterAfterProcess</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(CustomerInfo customerInfo)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 购买默认套餐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RegisterAfterProcess&gt; registerAfterProcessList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRegisterAfterProcessPattern</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = registerAfterProcessList.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size-<span class="number">1</span>)&#123;</span><br><span class="line">                registerAfterProcessList.get(i).setNext(<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                registerAfterProcessList.get(i).setNext(registerAfterProcessList.get(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(CustomerInfo customerInfo)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 保存用户</span></span><br><span class="line">        save(customerInfo);</span><br><span class="line">        <span class="comment">// 处理 after register</span></span><br><span class="line">        iregisterAfterProcessList.get(<span class="number">0</span>).after(customerInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="可控节点的责任链："><a href="#可控节点的责任链：" class="headerlink" title="可控节点的责任链："></a>可控节点的责任链：</h6><p><a href="https://blog.csdn.net/weixin_33910460/article/details/92608675" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33910460/article/details/92608675</a> </p><h5 id="4-模板方法模式"><a href="#4-模板方法模式" class="headerlink" title="4.模板方法模式"></a>4.模板方法模式</h5><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p><p><img src="/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2222997-f9f28c8d942ebd8d.webp" alt="img"></p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OrderPoolBo&gt; <span class="title">pullOrder</span><span class="params">(OrderRequest req)</span> </span>&#123;</span><br><span class="line">    String shopType = req.getShopType();</span><br><span class="line">    <span class="keyword">if</span>(shopType == <span class="string">"BS"</span>)&#123;</span><br><span class="line">        List&lt;BsOrder&gt; list = orderProvideToBdFeignClient.pullOrder(req);</span><br><span class="line">        <span class="comment">// 检查订阅关系</span></span><br><span class="line">        <span class="comment">// 过滤订单</span></span><br><span class="line">        <span class="comment">// 转成订单池的订单保存到数据库            </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shopType == <span class="string">"shopify"</span>)&#123;</span><br><span class="line">        List&lt;ShopifyOrder&gt; list = shopifyService.pullOrder(req);</span><br><span class="line">        <span class="comment">// 检查订阅关系</span></span><br><span class="line">        <span class="comment">// 过滤订单</span></span><br><span class="line">        <span class="comment">// 转成订单池的订单保存到数据库</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shopType == <span class="string">"wooc"</span>)&#123;</span><br><span class="line">        List&lt;woocOrer&gt; list = woocService.pullOrder(req);</span><br><span class="line">        <span class="comment">// 检查订阅关系</span></span><br><span class="line">        <span class="comment">// 过滤订单</span></span><br><span class="line">        <span class="comment">// 转成订单池的订单保存到数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上使我们目前拉单的一段代码流程大致相似 调用不同的第三方不同类型的订单最后过滤转化成统一的订单池订单，我们可以把相同的流程抽象出来不同的订单用泛型实现</p><p><strong>重构后的UM类图</strong></p><p><img src="/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200727001143558.png" alt="image-20200727001143558"></p><p><strong>店铺安装或者绑定类图</strong></p><p><img src="/2020/07/26/%E9%87%8D%E6%9E%84%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20200727001352214.png" alt="image-20200727001352214"></p><h4 id="设计模式落地"><a href="#设计模式落地" class="headerlink" title="设计模式落地"></a>设计模式落地</h4><p>设计模式提供的更多的是一种设计思想，如何运用还是要结合实际的场景。对于一个功能和需求一开始并不建议强扣设计模式，很多时候刚开始的需求是相对简单的，经过慢慢积累变的复杂化，这时候我们要改一些逻辑可能真的要牵一发而动全身，随着需求的不断完善我们可以从中抽丝剥茧提炼出一些公用的或者流程性的点，去不断的优化自己的代码。世界上没有完美的设计模式，结合自己的业务提供最大限度的可扩展、修改方便、阅读清晰就是最适合的设计模式，当然这也不是一蹴而就的代码本身就是一个不断优化的过程，只是设计模式会给我们提供多一点的参考，更多的是需要尝试解耦去分析业务以及在实际场景中的应用去实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构之常用设计模式&quot;&gt;&lt;a href=&quot;#重构之常用设计模式&quot; class=&quot;headerlink&quot; title=&quot;重构之常用设计模式&quot;&gt;&lt;/a&gt;重构之常用设计模式&lt;/h1&gt;&lt;p&gt;程序员三板斧：&lt;code&gt;数据结构&lt;/code&gt;、&lt;code&gt;算法&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>NIO-buffer</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/07/12/NIO-buffer/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/07/12/NIO-buffer/</id>
    <published>2020-07-12T12:31:27.572Z</published>
    <updated>2020-07-12T12:35:17.005Z</updated>
    
    <content type="html"><![CDATA[<p>1.BIO   NIO</p><p>2.BIO &amp; NIO的基本使用</p><p>3.NIO的新特性 buffer</p><p>example: IntBuffer     <code>capacity</code>   <code>postion</code>  <code>limit</code>  <code>mark</code>      </p><p>get()  </p><p>put() </p><p> mark() </p><p> reset()</p><p> flip()</p><p> clear()</p><p> rewind()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.BIO   NIO&lt;/p&gt;
&lt;p&gt;2.BIO &amp;amp; NIO的基本使用&lt;/p&gt;
&lt;p&gt;3.NIO的新特性 buffer&lt;/p&gt;
&lt;p&gt;example: IntBuffer     &lt;code&gt;capacity&lt;/code&gt;   &lt;code&gt;postion&lt;/code
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git使用小技巧</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/07/01/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/07/01/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-07-01T02:19:49.199Z</published>
    <updated>2020-07-01T02:23:51.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="删除某次提交"><a href="#删除某次提交" class="headerlink" title="删除某次提交"></a>删除某次提交</h4><p>1、首先找到<code>此次提交之前的一次</code>提交的 commit-id<br>2、执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commit-id</span><br></pre></td></tr></table></figure><p>3、编辑文件，将要删除的commit之前的单词改为drop ，然后按照提示保存退出</p><p>4、此已经删除了指定的commit，可以使用git log查看下<br>5、git push origin branch-name –force 然后推送到远程仓库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;删除某次提交&quot;&gt;&lt;a href=&quot;#删除某次提交&quot; class=&quot;headerlink&quot; title=&quot;删除某次提交&quot;&gt;&lt;/a&gt;删除某次提交&lt;/h4&gt;&lt;p&gt;1、首先找到&lt;code&gt;此次提交之前的一次&lt;/code&gt;提交的 commit-id&lt;br&gt;2、执行如下命令&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GitFlow工作流</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2020-05-20T06:50:51.000Z</published>
    <updated>2020-06-03T02:17:24.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发工作中优秀的编码固然重要，高效的使用工具、规范开发流程也是个人及团队协作中至关重要的一点，每个公司或者团队可能都会有自己的Git工作流程各有取舍，各有优缺点。本篇文章想和大家分享一些自己关于Git工作流程（PS:不是Git的使用教程）上的一些想法。</p><h3 id="1-什么是GitFlow"><a href="#1-什么是GitFlow" class="headerlink" title="1.什么是GitFlow?"></a>1.什么是GitFlow?</h3><blockquote><p>Git Flow 是由 Vincent Driessen（文森特·德里森） 在 2010年提出的一套基于Git的工作流程<code>标准</code>，定义了一个项目发布的分支<code>模型</code>，为管理具有预定发布周期的大型项目提供了一个健壮的框架，解决当分支过多时 , 如何有效快速管理这些分支.</p><p><a href="https://jeffkreeftmeijer.com/git-flow/" target="_blank" rel="noopener">https://jeffkreeftmeijer.com/git-flow/</a></p></blockquote><h4 id="1-1-GitFlow分支"><a href="#1-1-GitFlow分支" class="headerlink" title="1-1.GitFlow分支"></a>1-1.GitFlow分支</h4><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/e850352ac65c10384ddd401e94faf115b27e89b8.png" alt="e850352ac65c10384ddd401e94faf115b27e89b8"></p><h5 id="核心分支："><a href="#核心分支：" class="headerlink" title="核心分支："></a>核心分支：</h5><p><strong><code>master</code> ：</strong></p><ul><li>一个项目有且只能有一个master分支</li><li>存放的是随时可供在生产环境中部署的稳定版本代码</li><li>每次更新master，都需对master添加指定格式的tag，用于发布或回滚</li><li>这个分支只能从其它分支（release 或 hotfix）合并，不能在这个分支上直接修改</li></ul><p><strong><code>develop</code>：</strong></p><ul><li>一个项目有且只能有一个develop分支、派生自master分支</li><li>是保存当前最新开发成果的分支</li><li>包含所有要发布到下一个Release的代码</li></ul><h5 id="临时分支："><a href="#临时分支：" class="headerlink" title="临时分支："></a>临时分支：</h5><p><strong><code>feature</code>:</strong></p><ul><li>命名规则<code>feature/*</code></li><li>以功能为单位派生自develop分支</li><li>feature分支只与develop分支交互，开发完成后合并到develop分支</li></ul><p><strong><code>release</code>：</strong></p><ul><li>命名规则<code>release/*</code> </li><li>用来为发布新版的测试、修复做准备，派生自develop</li><li>测试环境bug直接在此分支删修复，并合并回develop分支</li><li>release分支测试通过后，合并到master分支并且给master打上新的版本tag</li></ul><p><strong><code>hotfix</code>：</strong></p><ul><li>命名规则<code>hotfix/*</code></li><li>主要用于线上修复，派生自master</li><li>完成bugv修复，必须合并回master分支和develop分支</li></ul><h4 id="1-2-Gitflow工具"><a href="#1-2-Gitflow工具" class="headerlink" title="1-2.Gitflow工具"></a>1-2.Gitflow工具</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><strong>mac osx</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git-flow</span><br></pre></td></tr></table></figure><ul><li><strong>windows</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化仓库创建master分支和develop分支，并自动切到develop分支</span></span><br><span class="line">git flow init</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个feature/V1.0的功能分支</span></span><br><span class="line">git flow feature start V1.0  </span><br><span class="line"></span><br><span class="line"><span class="comment">#把feature/V1.0分支推送到远程仓库</span></span><br><span class="line">git flow feature publish V1.0 </span><br><span class="line"></span><br><span class="line"><span class="comment">#把feature/V1.0合并到develop,并自动删除feature分支，切回develop分支</span></span><br><span class="line">git flow feature finish V1.0  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从develop 创建release/1.0分支</span></span><br><span class="line">git flow release start 1.0 </span><br><span class="line"></span><br><span class="line"><span class="comment">#把release/1.0 合并到master并给这次发布打tag,合并回develop删除release/1.0</span></span><br><span class="line">git flow release finish 1.0 </span><br><span class="line"></span><br><span class="line"><span class="comment">#基于master创建hotfix/bug1的修复分支</span></span><br><span class="line">git flow hotfix start bug1  </span><br><span class="line"></span><br><span class="line"><span class="comment">#结束一个hotfix分支，和release一样，同时合并回develop和master</span></span><br><span class="line">git flow hotfix finish bug1</span><br></pre></td></tr></table></figure><blockquote><p>Gitflow 是一个框架一个模型，习惯用Git 原生命令的可以继续用git命令实现以上操作</p></blockquote><h4 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1-3.应用"></a>1-3.应用</h4><p>上面说过Gitflow它是一个模型一个大致框架我们不必严格遵循，尽管有人吐槽它很复杂，我也尝试绕过它想看看有没有更好更简单流程，思来想去对比还是觉得GitFlow比较符合最佳实践，那结合我们的实际工作情况我们该如何落地Gitflow呢 ?   </p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200522092359083.png" alt="image-20200522092359083"></p><p>一般项目都会有<code>开发</code>、 <code>测试</code>、 <code>预生产</code>、 <code>生产</code> 四套环境，开发环境一般用于前后端或者服务间的联调稳定性要求不高，根据Gitflow规范</p><ul><li>以功能或以一个版本跌代为一个feature分支（版本周期小的敏捷开发建议以小版本为一个feature分支），由develop直接checkout或从develop commit记录checkout 用于新需求开发、联调自测，可部署到开发环境</li><li>develop严格控制merge权限，在feature分支开发完确定在下个迭代周期发布的才能MR (Merge Request)合并到develop分支，此MR可用作后期codereview</li><li>release 相对稳定派生自 develop分支，禁止从其他分支pull, 用于提测及测试环境bug修复，修复完的bug需要合并到develop分支</li><li>master 稳定分支，release分支合并过来需要打新版本tag 可用于预生产、生产环境部署</li><li>hotfix 修复预生产或生产环境bug修复完成需合并到master及develop</li></ul><blockquote><p><strong>优点：</strong></p><p>1.每个阶段我们只用关注一个分支，开发阶段只用关心feature分支，测试阶段只用关心release分支</p><p>2.分支作用域划分明确，单独release版本提测可以排除其他分支干扰（PS:我们目前是所有要提测不同版本功能都会合并到test分支，避免不了相互干扰的情况）</p><p><strong>缺点：</strong></p><p>1.有一定的学习成本需要团队成员对分支的理解一致</p></blockquote><h3 id="2-代码提交规范"><a href="#2-代码提交规范" class="headerlink" title="2.代码提交规范"></a>2.代码提交规范</h3><blockquote><p>有了统一Git分支管理规范，我们也需要统一代码格式统一提交规范，减少不必要的冲突以及更直观的查看代码提交记录</p></blockquote><h4 id="2-1-统一代码格式化"><a href="#2-1-统一代码格式化" class="headerlink" title="2-1.统一代码格式化"></a>2-1.统一代码格式化</h4><p>1.阿里编程规约 ，可以根据阿里巴巴开发手册扫描我们代码中的规范性（插件名称：Alibaba Java Coding Guideliens）</p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200521231713896.png" alt="image-20200521231713896"></p><p>2.插件 Eclipse Code Formatter </p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200521233358321.png" alt="image-20200521233358321"></p><p>Ctrl + Alt + L （mac : Command + Option + L） 可对代码进行快速格式化下图是格式化成功的提示</p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200521234109670.png" alt="image-20200521234109670"></p><h4 id="2-2-统一Commit格式"><a href="#2-2-统一Commit格式" class="headerlink" title="2-2.统一Commit格式"></a>2-2.统一Commit格式</h4><p>插件 Git Commit Template </p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200522000922509.png" alt="image-20200522000922509"></p><p><strong>type: commit 的类型（必填）</strong></p><ul><li>feat: 新特性</li><li>fix: 修改问题</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理.</li></ul><p><strong>scope</strong>: commit 影响的范围（选填）, 比如: user, component, utils, build…</p><p><strong>short description</strong>: 提交简述（必填）</p><p><strong>long description</strong>: 详细简述（选填）</p><p><strong>breaking changes &amp; close issues</strong>: 通常是 BREAKING CHANGE 或修复的 bug 的链接（选填）</p><p>效果：</p><p><img src="/2020/05/20/GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20200521234704632.png" alt="image-20200521234704632"></p><blockquote><p>ChangeLog</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;开发工作中优秀的编码固然重要，高效的使用工具、规范开发流程也是个人及团队协作中至关重要的一点，每个公司或者团队可能都会有自己的Git工作流程
      
    
    </summary>
    
    
    
      <category term="-Git" scheme="http://igeek2020.gitee.io/test_page/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-16T10:15:01.000Z</published>
    <updated>2020-05-23T12:13:08.082Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis中的模板方法模式：</p><p>执行器：</p><p><img src="/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/image-20200523201300733.png" alt="image-20200523201300733"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mybatis中的模板方法模式：&lt;/p&gt;
&lt;p&gt;执行器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/image
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://igeek2020.gitee.io/test_page/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis进阶（一）</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/05/16/Mybtais%E8%BF%9B%E9%98%B6(%E4%B8%80)/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/05/16/Mybtais%E8%BF%9B%E9%98%B6(%E4%B8%80)/</id>
    <published>2020-05-16T10:15:01.000Z</published>
    <updated>2020-07-04T14:16:10.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>MyBatis</code> 是一个基于Java的持久层框架，相信大家应该都有所了解，平时工作中你也可能正在使用,但是你真的了解其底层实现吗？MyBatis的执行流程是怎么样的？一级缓存和二级缓存又是怎么实现的呢？查询的结果又是如何映射到我们的实体中的？等等一系列问题接下来我会以多个篇幅来从源码的角度和大家一起揭秘MyBatis的面纱。</p><h3 id="JDBC执行过程"><a href="#JDBC执行过程" class="headerlink" title="JDBC执行过程"></a>JDBC执行过程</h3><p>在深入<code>Mybatis</code>之前我们先来回顾一下，<code>JDBC</code>是如何操作数据库的 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获得数据库连接</span></span><br><span class="line">Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line"><span class="comment">// 2.预编译SQL</span></span><br><span class="line">PreparedStatement sql = connection.prepareStatement(<span class="string">"select * from users where id = ?"</span>);</span><br><span class="line">sql.setInt(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 3.执行SQL</span></span><br><span class="line">sql.execute();</span><br><span class="line"><span class="comment">// 4.读取结果</span></span><br><span class="line">ResultSet resultSet = sql.getResultSet();</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">System.out.println(resultSet.getString(<span class="number">1</span>));</span><br><span class="line">System.out.println(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/16/Mybtais%E8%BF%9B%E9%98%B6(%E4%B8%80)/image-20200704214556230.png" alt="image-20200704214556230"></p><blockquote><p>★ JDBC的三种执行器：</p><ul><li><code>Statement</code> 简单执行器，普通的不带参的查询SQL (PS:适合静态SQL)</li><li><code>PreparedStatement</code> 预编译执行器，预编译SQL能重复使用，可防SQL注入</li><li><code>CallableStatement</code> 存储过程执行器，支持调用存储过程,提供了输入/输出参数(INOUT)的支持</li></ul></blockquote><h3 id="Mybatis执行过程"><a href="#Mybatis执行过程" class="headerlink" title="Mybatis执行过程"></a>Mybatis执行过程</h3><p>会顾完JDBC的执行过程我们再来看看Mybtais的执行过程</p><p>mapper sqlsession executor statement mysql</p><p>//一级缓存</p><p>//二级缓存 </p><p>//门面模式  定义了很多查询的方法</p><p>SqlSession  ==&gt; defaulfSqlSession </p><p>​                    </p><p>执行器</p><p>​                    ==&gt; CacheExecutor   // 装饰器模式</p><p>Executor   =&gt;  BaseExecutor    //  模板方法模式  </p><p>​                                    ==&gt;SimpleExecutor</p><p>​                                    ==&gt;ReuseExecutor</p><p>​                                    ==&gt;BatchExecutor</p><p>串杂设计模式：</p><p>门面模式：</p><p>装饰器模式：</p><p>简单工厂模式：</p><p>模板方法模式：</p><p>MetaObject</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MyBatis&lt;/code&gt; 是一个基于Java的持久层框架，相信大家应该都有所了解，平时工作中你也可能正在使用,但是你真的了解
      
    
    </summary>
    
    
    
      <category term="Mybatis" scheme="http://igeek2020.gitee.io/test_page/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Hexo搭建自己的个人博客</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-16T08:26:24.000Z</published>
    <updated>2020-05-16T10:07:20.359Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200516163743725.png" alt="image-20200516163743725" style="zoom:150%;"><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><blockquote><ol><li>注册一个GitHub账号  </li><li>安装git、node.js（自行安装很简单 直接下一步到底）</li><li>条件允许的话可以申请一个个人的域名 （非必须）</li></ol></blockquote><h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h2><p>创建一个名为<code>你的用户名.github.io</code>的仓库，比如我的github用户名为 <code>igeekcoder</code>,即创建一个名称为<code>igeekcoder.github.io</code> 的仓库（其他名称默认无效）， 如下图其它内容可以不用填写勾选，点击Create repository 即可创建。</p><p>ps: 由于我已经创建过了它会提示我仓库已存在</p><p><img src="/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200516173407937.png" alt="image-20200516173407937"></p><h2 id="3-配置SSH-Key"><a href="#3-配置SSH-Key" class="headerlink" title="3.配置SSH Key"></a>3.配置SSH Key</h2><h4 id="3-1-检查本机是否已经有SSH-Key。"><a href="#3-1-检查本机是否已经有SSH-Key。" class="headerlink" title="3-1.检查本机是否已经有SSH Key。"></a>3-1.检查本机是否已经有SSH Key。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cd &#x2F;.ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure><img src="/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200516174437602.png" alt="image-20200516174437602" style="zoom:150%;"><p>如果提示：<code>No such file or directory</code> 说明你是第一次使用git。</p><h4 id="3-2-生成你的SSH-Key"><a href="#3-2-生成你的SSH-Key" class="headerlink" title="3-2.生成你的SSH Key"></a>3-2.生成你的SSH Key</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "你的邮箱地址"</span><br></pre></td></tr></table></figure><p>使用以上命令直接回车，不用填写东西。之后会让你输入密码（可以不输入密码，直接为空，这样更新代码不用每次输入 id_rsa 密码了）。然后就生成一个目录.ssh ，里面有两个文件：id_rsa , id_rsa.pub（id_rsa中保存的是私钥，id_rsa.pub中保存的是公钥）</p><h4 id="3-3-添加SSH-Key到GitHub"><a href="#3-3-添加SSH-Key到GitHub" class="headerlink" title="3-3.添加SSH Key到GitHub"></a>3-3.添加SSH Key到GitHub</h4><p>将公钥id_rsa.pub的内容复制到 Settings &gt;&gt; SSH And GPG keys &gt;&gt; new 新创建一个SSH Key</p><p><img src="/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200516175723532.png" alt="image-20200516175723532"></p><p>使用一下命令测试是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src="/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20200516180041606.png" alt="image-20200516180041606" style="zoom:150%;"><h2 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://igeek2020.gitee.io/test_page/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>First_Blog</title>
    <link href="http://igeek2020.gitee.io/test_page/2020/05/01/First_Blog/"/>
    <id>http://igeek2020.gitee.io/test_page/2020/05/01/First_Blog/</id>
    <published>2020-05-01T08:02:41.000Z</published>
    <updated>2020-05-01T08:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>新的开始决定以博客的形式记录分享学习的笔记，内容以java为主，技术栈包含<code>spring 全家桶</code>、<code>Java基础</code>、<code>mysql</code>、<code>dubbo</code>、<code>zookeeper</code>、<code>kafka</code>、<code>netty</code>、<code>ELK</code>、<code>nosql</code> 等等分布式或微服务场景常用的技术   let’s do it！</p></blockquote><p><img src="/2020/05/01/First_Blog/timg-1588761416214-1588762807786.jpg" alt="timg-1588761416214-1588762807786"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;新的开始决定以博客的形式记录分享学习的笔记，内容以java为主，技术栈包含&lt;code&gt;spring 全家桶&lt;/code&gt;、&lt;code&gt;Java基础&lt;/code&gt;、&lt;code&gt;mysql&lt;/code&gt;、&lt;code&gt;dubbo&lt;/code&gt;、&lt;code
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
