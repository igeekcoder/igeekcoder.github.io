[{"title":"TransactionalEventListener","date":"2020-12-12T07:27:51.353Z","path":"2020/12/12/TransactionalEventListener/","text":"","tags":[]},{"title":"装饰器模式","date":"2020-12-06T11:33:16.764Z","path":"2020/12/06/装饰器模式/","text":"装饰器模式 定义：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 看上面的定义还是很抽象我们来举个具体的例子","tags":[]},{"title":"Mybatis执行器（Executor）","date":"2020-12-05T10:15:01.000Z","path":"2020/12/05/MyBatis源码解析一(执行器)/","text":"Mybatis执行器(Executor)1.JDBC执行流程在介绍Mybatis执行器之前我们先回顾一下JDBC的执行流程方便我们理解什么是执行器 (如下图) image-20201206151753117 1234567891011121314151617181920212223242526// jdbc demopublic static final String URL = \"jdbc:mysql://192.168.0.4:3306/test\";public static final String USERNAME = \"root\";public static final String PASSWORD = \"123456\";// 1.获得数据库连接@Beforepublic void init() throws SQLException &#123; connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);&#125;@Testpublic void prepareTest() throws SQLException &#123; String sql = \"SELECT `name` FROM users\"; // 2.预编译sql PreparedStatement preparedStatement = connection.prepareStatement(sql); // 3.执行sql preparedStatement.execute(); ResultSet resultSet = preparedStatement.getResultSet(); // 4.读取结果 while (resultSet.next()) &#123; System.out.println(resultSet.getString(1)); &#125; resultSet.close(); preparedStatement.close();&#125; 2.Mybatis基本执行流程上面我们简单回顾了JDBC的基本执行流程，Mybatis不过在JDBC的基础之上更加方便和高效的让我操作数据库，我们用一段简单的demo探索Mybtais是如何执行的 123456789101112131415public static void main(String[] args) throws IOException &#123; // 指定全局配置文件 String resource = \"mybatis-config.xml\"; // 读取配置文件 InputStream inputStream = Resources.getResourceAsStream(resource); // 构建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId // 第二个参数：指定传入sql的参数：这里是用户id Test test = sqlSession.selectOne(\"TestMapper.selectTest\", 1); System.out.println(test.getName());&#125; 可以看到SqlSession是我们使用Mybatis的入口(PS:这里使用的是门面模式),SqlSession是一个接口定义了很多门面方法来方便我们使用Mybatis，它的默认实现是DefaultSqlSession，它包括增、删、改、查，以及会话相关的管理如会话的提交、回滚、关闭等方法。具体的执行流程如下图： image-20201206160515647 /image-20201206160515647.png image-20201206160018738 大致执行流程如上图所示，如调用sqlSession的selectOne()方法，调用具体的Executor执行器，最后真正干活的是StatementHandler,他需要处理参数和结果，调用JDBC查询到结果（后面会详细分析这块源码） 3.执行器（Exectuor）每一个sqlSession都拥有一个Exectuor对象，它负责增删改查的具体操作，下图是Executor的继承关系图 image-20201206151013893 BaseExecutor这里典型的采用了模板方法的设计模式(PS:看源码不仅要看具体的实现原理，更多的是学习大佬们是如何编写代码的)，该类抽象出SimpleExecutor、ReuseExecutor、BatchExecutor的通用逻辑； SimpleExecutor：简单执行器，是MyBatis中默认使用的执行器，每执行一次update或select，就开启一个Statement对象，用完就直接关闭Statement对象； ReuseExecutor：可重用执行器，这里的重用指的是重复使用Statement，它会在内部使用一个Map把创建的Statement都缓存起来，每次执行SQL命令的时候，都会去判断是否存在基于该SQL的Statement对象，如果存在Statement对象并且对应的connection还没有关闭的情况下就继续使用之前的Statement对象，如果不存在则构建Statement并将其缓存起来。因为每一个SqlSession都有一个新的Executor对象，所以我们缓存在ReuseExecutor上的Statement作用域是同一个SqlSession;（核心代码如下图） image-20201206204533731 BatchExecutor: 批处理执行器，用于将多个SQL一次性输出到数据库; BatchExecutor批处理doUpdate,连续相同的sql &amp; statement才会共用同一个statement进行批处理，详情见 org.apache.ibatis.executor.BatchExecutor#doUpdate CahingExecutor: 缓存执行器（二级缓存），此处是一个装饰器模式的实现，先从缓存中查询结果，如果存在，就返回；如果不存在，再委托给Executor delegate 去数据库中取，delegate可以是上面任何一个执行器； *二级缓存相对复杂、下篇会单独分析，敬请期待*","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://igeek2020.gitee.io/tags/Mybatis/"},{"name":"设计模式","slug":"设计模式","permalink":"http://igeek2020.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JDK8-函数式接口","date":"2020-11-23T02:19:28.636Z","path":"2020/11/23/JDK8-函数式接口/","text":"JDK8 函数式接口概念函数式接口在java中是指:有且仅有一个抽象方法的接口","tags":[]},{"title":"TCP-IP","date":"2020-09-13T06:04:43.507Z","path":"2020/09/13/TCP-IP/","text":"TCP/IP img JSR 269规范 lombok","tags":[]},{"title":"GitFlow工作流","date":"2020-05-20T06:50:51.000Z","path":"2020/05/20/GitFlow工作流/","text":"前言开发工作中优秀的编码固然重要，高效的使用工具、规范开发流程也是个人及团队协作中至关重要的一点，每个公司或者团队可能都会有自己的Git工作流程各有取舍，各有优缺点。本篇文章想和大家分享一些自己关于Git工作流程（PS:不是Git的使用教程）上的一些想法。 1.什么是GitFlow? Git Flow 是由 Vincent Driessen（文森特·德里森） 在 2010年提出的一套基于Git的工作流程标准，定义了一个项目发布的分支模型，为管理具有预定发布周期的大型项目提供了一个健壮的框架，解决当分支过多时 , 如何有效快速管理这些分支. https://jeffkreeftmeijer.com/git-flow/ 1-1.GitFlow分支 e850352ac65c10384ddd401e94faf115b27e89b8 核心分支：master ： 一个项目有且只能有一个master分支 存放的是随时可供在生产环境中部署的稳定版本代码 每次更新master，都需对master添加指定格式的tag，用于发布或回滚 这个分支只能从其它分支（release 或 hotfix）合并，不能在这个分支上直接修改 develop： 一个项目有且只能有一个develop分支、派生自master分支 是保存当前最新开发成果的分支 包含所有要发布到下一个Release的代码 临时分支：feature: 命名规则feature/* 以功能为单位派生自develop分支 feature分支只与develop分支交互，开发完成后合并到develop分支 release： 命名规则release/* 用来为发布新版的测试、修复做准备，派生自develop 测试环境bug直接在此分支删修复，并合并回develop分支 release分支测试通过后，合并到master分支并且给master打上新的版本tag hotfix： 命名规则hotfix/* 主要用于线上修复，派生自master 完成bugv修复，必须合并回master分支和develop分支 1-2.Gitflow工具安装 mac osx 1$ brew install git-flow windows 1$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash 使用1234567891011121314151617181920212223#初始化仓库创建master分支和develop分支，并自动切到develop分支git flow init#创建一个feature/V1.0的功能分支git flow feature start V1.0 #把feature/V1.0分支推送到远程仓库git flow feature publish V1.0 #把feature/V1.0合并到develop,并自动删除feature分支，切回develop分支git flow feature finish V1.0 #从develop 创建release/1.0分支git flow release start 1.0 #把release/1.0 合并到master并给这次发布打tag,合并回develop删除release/1.0git flow release finish 1.0 #基于master创建hotfix/bug1的修复分支git flow hotfix start bug1 #结束一个hotfix分支，和release一样，同时合并回develop和mastergit flow hotfix finish bug1 Gitflow 是一个框架一个模型，习惯用Git 原生命令的可以继续用git命令实现以上操作 1-3.应用上面说过Gitflow它是一个模型一个大致框架我们不必严格遵循，尽管有人吐槽它很复杂，我也尝试绕过它想看看有没有更好更简单流程，思来想去对比还是觉得GitFlow比较符合最佳实践，那结合我们的实际工作情况我们该如何落地Gitflow呢 ? 一般项目都会有开发、 测试、 预生产、 生产 四套环境，开发环境一般用于前后端或者服务间的联调稳定性要求不高，根据Gitflow规范 以功能或以一个版本跌代为一个feature分支（版本周期小的敏捷开发建议以小版本为一个feature分支），由develop直接checkout或从develop commit记录checkout 用于新需求开发、联调自测，可部署到开发环境 develop严格控制merge权限，在feature分支开发完确定在下个迭代周期发布的才能MR (Merge Request)合并到develop分支，此MR可用作后期codereview release 相对稳定派生自 develop分支，禁止从其他分支pull, 用于提测及测试环境bug修复，修复完的bug需要合并到develop分支 master 稳定分支，release分支合并过来需要打新版本tag 可用于预生产、生产环境部署 hotfix 修复预生产或生产环境bug修复完成需合并到master及develop 优点： 1.每个阶段我们只用关注一个分支，开发阶段只用关心feature分支，测试阶段只用关心release分支 2.分支作用域划分明确，单独release版本提测可以排除其他分支干扰（PS:我们目前是所有要提测不同版本功能都会合并到test分支，避免不了相互干扰的情况） 缺点： 1.有一定的学习成本需要团队成员对分支的理解一致 2.代码提交规范 有了统一Git分支管理规范，我们也需要统一代码格式统一提交规范，减少不必要的冲突以及更直观的查看代码提交记录 2-1.统一代码格式化1.阿里编程规约 ，可以根据阿里巴巴开发手册扫描我们代码中的规范性（插件名称：Alibaba Java Coding Guideliens） image-20200521231713896 2.插件 Eclipse Code Formatter Ctrl + Alt + L （mac : Command + Option + L） 可对代码进行快速格式化下图是格式化成功的提示 image-20200521234109670 2-2.统一Commit格式插件 Git Commit Template type: commit 的类型（必填） feat: 新特性 fix: 修改问题 refactor: 代码重构 docs: 文档修改 style: 代码格式修改, 注意不是 css 修改 test: 测试用例修改 chore: 其他修改, 比如构建流程, 依赖管理. scope: commit 影响的范围（选填）, 比如: user, component, utils, build… short description: 提交简述（必填） long description: 详细简述（选填） breaking changes &amp; close issues: 通常是 BREAKING CHANGE 或修复的 bug 的链接（选填） 效果： image-20200521234704632 ChangeLog","tags":[{"name":"Git","slug":"Git","permalink":"http://igeek2020.gitee.io/tags/Git/"}]},{"title":"Gits使用小技巧","date":"2020-05-20T06:50:51.000Z","path":"2020/05/20/Git使用小技巧/","text":"删除某次提交1、首先找到此次提交之前的一次提交的 commit-id2、执行如下命令 1git rebase -i commit-id 3、编辑文件，将要删除的commit之前的单词改为drop ，然后按照提示保存退出 4、此已经删除了指定的commit，可以使用git log查看下5、git push origin branch-name –force 然后推送到远程仓库","tags":[{"name":"Git","slug":"Git","permalink":"http://igeek2020.gitee.io/tags/Git/"}]},{"title":"设计模式-模板方法","date":"2020-05-16T10:15:01.000Z","path":"2020/05/16/设计模式-模板方法/","text":"mybatis中的模板方法模式： 执行器：","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://igeek2020.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"重构之常用设计模式","date":"2020-05-16T10:15:01.000Z","path":"2020/05/16/重构之设计模式/","text":"重构之常用设计模式程序员三板斧：数据结构、算法、设计模式 作为程序员无论你学习使用的是哪种语言，这三板斧都需要涉及甚至是需要深入了解的，这也是一个程序员基本功的展现，最近在做一些业务代码的重构也尝试使用了一些设计模式，今天和大家聊一聊我的一些见解和工作常用的一些设计模式 设计模式是什么？ 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 常用的设计模式1.单例模式单例（Singleton）模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。在实际开发过程中，我们常常需要保存一些数据实现全局共享，这时候就需要用到单例模式。单例模式是在实际开发过程中使用比较多的一种设计模式。 单例模式在spring中广泛应用 spring默认bean也是单例，适用于一些无状态的类，减少类的创建和销毁，需要注意的是共享变量需要考虑线程安全的问题，相对比较简单对于有些设计模式大师来说可能都算不上一种设计模式，更确切的来说是一种方法技巧, 这里就不详细分析了 2.策略模式举个栗子: 123456789101112131415161718/** * 订单支付 * * @param payType * @param orderBO */public void pay (String payType, OrderBO orderBO) &#123; if (\"paypal\".equals(payType)) &#123; // paypal 支付逻辑 &#125; else if (\"wechatPay\".equals(payType)) &#123; // 微信支付逻辑 &#125; else if (\"aliPay\".equals(payType)) &#123; // 支付宝支付逻辑 &#125;else if (\"unionPay\".equals(payType))&#123; // 银联支付逻辑 &#125;&#125; 类似上面这段代码，我们在平时开发中可能会经常见到，存在什么问题？条件分支多，并且可能有持续增长的趋势 ，更有些判断条件复杂，上下文中的参数可能相互影响 并且if 里面可能还需要嵌套 if 或者 循环体 整个代码看着就很臃肿改起来很容易出错， 下面我们用策略模式实现 策略模式的定义：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，一般情况下我们是将一种行为写成一个类方法，比如计算器类中有加、减、乘、除四种方法，而策略模式则是将每一种算法都写成一个类，然后动态地选择使用哪一个算法 从 UML 类图中，我们可以看到，策略模式 主要包含三种角色： 上下文角色（Context）：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略，算法的直接访问，封装可能存在的变化； 抽象策略角色（Strategy）：规定策略或算法的行为； 具体策略角色（ConcreteStrategy）：具体的策略或算法实现； 在Spring中使用策略模式后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 支付接口 * * @param orderBO */public interface Payment &#123; void pay( OrderBO orderBO);&#125;@Component(\"paypal\")public class PayPal implements Payment&#123; @Override public void pay(OrderBO orderBO) &#123; // paypal 支付 &#125;&#125;@Component(\"wechatPay\")public class WechatPay implements Payment&#123; @Override public void pay(OrderBO orderBO) &#123; // wechatPay 支付逻辑 &#125;&#125;@Componentpublic class AliPay implements Payment&#123; @Override public void pay(OrderBO orderBO) &#123; // aliPay 支付逻辑 &#125; @Override public String toString() &#123; return \"aliPay\"; &#125;&#125;........ public class PayTest &#123; @Autowired private Map&lt;String, Payment&gt; paymentMap; public void pay(String payType, OrderBO orderBO) &#123; Payment payment = paymentMap.get(payType); payment.pay(orderBO); &#125;&#125; 这样各种支付方式相互独立清晰，需要接入新的支付方式只需要实现Payment 接口就可以了原有的支付逻辑都是可以不用去改变，从而实现 开闭原则（对扩展开放，对修改关闭）。 3.责任链模式责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。 img 简单责任链举个栗子： 12345678910111213141516171819202122232425262728293031323334/** * 注册 * */public void register(CustomerInfo customerInfo)&#123; // 保存用户 save(customerInfo); // 1.发送邮件 sendSuccessEmail(customerInfo.getEmail()); // 2.初始化setting initSetting(customerInfo); // 3.购买默认0元套餐 buyCombo(customerInfo.getCustomerCode()); // 4.默认选择 selectPackageMethod(customerInfo); // 5. 6 7&#125;/** * 下单 * */public void createOrder(OrderBO orderBO)&#123; // 1.基本参数检查 checkParam(orderBO); // 2.风控检查 riskCheck(orderBo) // 3.商品库存检查 checkGoods(orderBo) // 4. 5 6&#125; 以上是一段伪代码 第一注册功能 注册完之后需要给用户发送邮件，初始化默认设置，购买默认套餐，选择默认打包服务 第二个是一个下单功能 下单前要做各种检查 没准什么时候又来个购买的服务数量检查等等 在spring中使用有顺序的责任链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Datapublic abstract class AfterRegisterHandler &#123; private AfterRegisterHandler next; public final void after(CustomerInfo customerInfo) &#123; doAfter(customerInfo); if (getNext()!=null)&#123; getNext().doAfter(customerInfo); &#125; &#125; public abstract String doAfter(CustomerInfo customerInfo);&#125;@Order(1)@Componentpublic class DefaultRegisterAfterProcess extends RegisterAfterProcess&#123; @Override public void doAfter(CustomerInfo customerInfo) &#123; // 发送邮件 &#125;&#125;@Order(2)@Componentpublic class ComboRegisterAfterProcess extends RegisterAfterProcess&#123; @Override public void doAfter(CustomerInfo customerInfo) &#123; // 购买默认套餐 &#125;&#125;@Datapublic class Test &#123; @Autowired private List&lt;RegisterAfterProcess&gt; registerAfterProcessList; @PostConstruct private void initRegisterAfterProcessPattern()&#123; int size = registerAfterProcessList.size(); for (int i = 0; i &lt; size; i++) &#123; if (i == size-1)&#123; registerAfterProcessList.get(i).setNext(null); &#125;else &#123; registerAfterProcessList.get(i).setNext(registerAfterProcessList.get(i+1)); &#125; &#125; &#125; public void register(CustomerInfo customerInfo)&#123; // 保存用户 save(customerInfo); // 处理 after register iregisterAfterProcessList.get(0).after(customerInfo); &#125;&#125; 可控节点的责任链：https://blog.csdn.net/weixin_33910460/article/details/92608675 4.模板方法模式定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 举个栗子： 12345678910111213141516171819public List&lt;OrderPoolBo&gt; pullOrder(OrderRequest req) &#123; String shopType = req.getShopType(); if(shopType == \"BS\")&#123; List&lt;BsOrder&gt; list = orderProvideToBdFeignClient.pullOrder(req); // 检查订阅关系 // 过滤订单 // 转成订单池的订单保存到数据库 &#125;else if (shopType == \"shopify\")&#123; List&lt;ShopifyOrder&gt; list = shopifyService.pullOrder(req); // 检查订阅关系 // 过滤订单 // 转成订单池的订单保存到数据库 &#125;else if(shopType == \"wooc\")&#123; List&lt;woocOrer&gt; list = woocService.pullOrder(req); // 检查订阅关系 // 过滤订单 // 转成订单池的订单保存到数据库 &#125;&#125; 以上使我们目前拉单的一段代码流程大致相似 调用不同的第三方不同类型的订单最后过滤转化成统一的订单池订单，我们可以把相同的流程抽象出来不同的订单用泛型实现 重构后的UM类图 image-20200727001143558 店铺安装或者绑定类图 image-20200727001352214 设计模式落地设计模式提供的更多的是一种设计思想，如何运用还是要结合实际的场景。对于一个功能和需求一开始并不建议强扣设计模式，很多时候刚开始的需求是相对简单的，经过慢慢积累变的复杂化，这时候我们要改一些逻辑可能真的要牵一发而动全身，随着需求的不断完善我们可以从中抽丝剥茧提炼出一些公用的或者流程性的点，去不断的优化自己的代码。世界上没有完美的设计模式，结合自己的业务提供最大限度的可扩展、修改方便、阅读清晰就是最适合的设计模式，当然这也不是一蹴而就的代码本身就是一个不断优化的过程，只是设计模式会给我们提供多一点的参考，更多的是需要尝试解耦去分析业务以及在实际场景中的应用去实践。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://igeek2020.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"重构","slug":"重构","permalink":"http://igeek2020.gitee.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"如何使用Hexo搭建自己的个人博客","date":"2020-05-16T08:26:24.000Z","path":"2020/05/16/如何使用Hexo搭建自己的个人博客/","text":"1.准备工作 注册一个GitHub账号 安装git、node.js（自行安装很简单 直接下一步到底） 条件允许的话可以申请一个个人的域名 （非必须） 2.创建仓库创建一个名为你的用户名.github.io的仓库，比如我的github用户名为 igeekcoder,即创建一个名称为igeekcoder.github.io 的仓库（其他名称默认无效）， 如下图其它内容可以不用填写勾选，点击Create repository 即可创建。 ps: 由于我已经创建过了它会提示我仓库已存在 image-20200516173407937 3.配置SSH Key3-1.检查本机是否已经有SSH Key。1$cd &#x2F;.ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 3-2.生成你的SSH Key1$ ssh-keygen -t rsa -C \"你的邮箱地址\" 使用以上命令直接回车，不用填写东西。之后会让你输入密码（可以不输入密码，直接为空，这样更新代码不用每次输入 id_rsa 密码了）。然后就生成一个目录.ssh ，里面有两个文件：id_rsa , id_rsa.pub（id_rsa中保存的是私钥，id_rsa.pub中保存的是公钥） 3-3.添加SSH Key到GitHub将公钥id_rsa.pub的内容复制到 Settings &gt;&gt; SSH And GPG keys &gt;&gt; new 新创建一个SSH Key image-20200516175723532 使用一下命令测试是否成功 1$ ssh -T git@github.com 4.安装Hexo","tags":[{"name":"hexo","slug":"hexo","permalink":"http://igeek2020.gitee.io/tags/hexo/"}]},{"title":"NIO Buffer","date":"2019-12-16T10:15:01.000Z","path":"2019/12/16/NIO-buffer/","text":"1.BIO NIO 2.BIO &amp; NIO的基本使用 3.NIO的新特性 buffer example: IntBuffer capacity postion limit mark get() put() mark() reset() flip() clear() rewind()","tags":[{"name":"NIO","slug":"NIO","permalink":"http://igeek2020.gitee.io/tags/NIO/"}]}]